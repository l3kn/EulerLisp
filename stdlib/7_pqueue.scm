;; Min-priority queue,
;; See Ch. 6.5 of “Introduction to Algorithms”
(defn make-pqueue (els)
      (defn loop (pq idx)
            (when (>= idx 0)
                (pqueue-max-heapify! pq idx)
                (loop pq (dec idx))))
      (let ((pq (list->vector els)))
        (loop pq (dec (div (vector-length pq) 2)))
        pq))

(defn pqueue-parent (idx) (div (dec idx) 2))
(defn pqueue-left   (idx) (+ (* 2 idx) 1))
(defn pqueue-right  (idx) (+ (* 2 idx) 2))

(defn pqueue-max-heapify! (pq idx)
      (let ((l (pqueue-left idx))
            (r (pqueue-right idx))
            (size (vector-length pq)))
        (let ((smallest (if (and (< l size)
                                 (< (rst (vector-ref pq l))
                                    (rst (vector-ref pq idx))))
                           l idx)))
          (if (and (< r size)
                   (< (rst (vector-ref pq r))
                      (rst (vector-ref pq smallest))))
            (set! smallest r))
          (when (!= smallest idx)
                (vector-swap! pq idx smallest)
                (pqueue-max-heapify! pq smallest)))))

(defn pqueue-swap! (pq idx)
      (if (> idx 0)
          (let ((p (pqueue-parent idx)))
            (when (< (rst (vector-ref pq idx))
                     (rst (vector-ref pq p)))
                  (vector-swap! pq idx p)
                  (pqueue-swap! pq p)))))

(defn pqueue-peek (pq)
      (if (> (vector-length pq) 0)
          (vector-ref pq 0)))

(defn pqueue-dequeue! (pq)
      (when (> (vector-length pq) 0)
            (vector-swap! pq 0 (dec (vector-length pq)))
            (let ((min-elem (vector-pop! pq)))
              (pqueue-max-heapify! pq 0)
              min-elem)))

(defn pqueue-enqueue! (pq val prio)
      (vector-push! pq (cons val prio))
      (pqueue-swap! pq (dec (vector-length pq))))
